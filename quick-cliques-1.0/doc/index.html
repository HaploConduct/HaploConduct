<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>Quick Cliques: A package to efficiently compute all maximal cliques in sparse graphs</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li class="current"><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<h1>Quick Cliques: A package to efficiently compute all maximal cliques in sparse graphs </h1>  </div>
</div>
<div class="contents">
<dl class="author"><dt><b>Author:</b></dt><dd>Darren Strash (first name DOT last name AT gmail DOT com)</dd></dl>
<p>Copyright (c) 2011 Darren Strash. This code is released under the GNU Public License (GPL) 3.0.</p>
<div align="center">
<img src="gplv3-127x51.png" alt="gplv3-127x51.png"/>
</div>
 
    <center>
    <a href="gpl-3.0-standalone.html">See GPL 3.0 here</a>
    </center>
    <h2><a class="anchor" id="intro_sec"></a>
Introduction</h2>
<p>This package contains the code that was used to generate the results of Eppstein and Strash (2011). (See <a class="el" href="index.html#recommended_reading">Recommended Reading</a> for references I am using.)</p>
<p>This package contains code to generate all maximal cliques of graphs. It contains implementations of the following algorithms:</p>
<ol type="1">
<li><b>(tomita)</b> The algorithm of Tomita et al. (2006), which is known to work well in practice, but consumes much memory because it uses an adjacency matrix representation of the input graph. For <b> small </b> sparse graphs, this algorithm is an excellent choice, and it is worst-case optimal. This algorithm also works very fast in practice for dense graphs. <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="tomita_8c.html" title="Execute the tomita algorithm in tomita_algorithm.c and print the number of cliques found and wall clo...">tomita.c</a> <a class="el" href="tomita__algorithm_8c.html" title="This file contains the algorithm for listing all cliques according to the algorithm of Tomita et al...">tomita_algorithm.c</a> <br/>
<br/>
</dd></dl>
</li>
<li><b>(tomita-adjacency-list)</b> The algorithm of Tomita et al. (2006), modified to use adjacency lists, therefore only requiring space linear in the size of the graph. This version is explained in the paper by Eppstein and Strash (2011), and is referred to in their paper as the "max-degree" algorithm. For sparse graphs, this algorithm can be quite fast on some inputs, but very slow on others. In particular, there are some sparse graphs that cause this algorithm to run for over 5 hours, when the <b>hybrid</b> and <b>degeneracy</b> algorithms described next takes 10 and 4 minutes, respectively. This behavior is likely because there are some high-degree vertices whose neighbor lists are iterated througha many times. Therefore, <em>use caution</em> when running this algorithm. <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="adjlist_8c.html" title="Execute the adjlist algorithm in adjlist_algorithm.c and print the number of cliques found and wall c...">adjlist.c</a> <a class="el" href="adjlist__algorithm_8c.html" title="This file contains the main algorithm for listing all cliques according to the algorithm of Tomita et...">adjlist_algorithm.c</a> <br/>
<br/>
</dd></dl>
</li>
<li><b>(hybrid)</b> An implementation of the algorithm of Eppstein, Löffler, and Strash (2010), which computes a degeneracy ordering of the input graph, and uses this ordering to speed up computation without any fancy data structuring. This algorithm is called "hybrid" in Eppstein and Strash (2011). For sparse graphs, this algorithm is consistently fast in practice, it is especially fast when the degeneracy of the graph is <b>very small</b> (for example, less than 6), or with graphs whose vertices, on average, have very few later neighbors in the degeneracy ordering. However, with larger degeneracy graphs, and graphs whose vertices have, on average, many more later neighbors in the degeneracy ordering, using <b>degeneracy</b>, the algorithm described next, is typically faster. Why? It uses a more complex data structure that lets us gets us better speed in this case. <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="hybrid_8c.html" title="Execute the algorithm in hybrid_algorithm.c and print the number of cliques found and wall clock exec...">hybrid.c</a> <a class="el" href="hybrid__algorithm_8c.html" title="This file contains an algorithm for listing all cliques according to the &quot;hybrid&quot; algorithm...">hybrid_algorithm.c</a> <br/>
<br/>
</dd></dl>
</li>
<li><b>(degeneracy)</b> The algorithm of Eppstein, Löffler, and Strash (2010), which computes a degeneracy ordering of the input graph, and builds a data structure to speed up computation. This algorithm is called "degeneracy" in Eppstein and Strash (2011). For sparse graphs, this algorithm is consistently fast in practice, it is particular fast when the degeneracy of the graph is higher than 6, or with graphs whose vertices, on average, have many later neighbors in the degeneracy ordering. <dl class="see"><dt><b>See also:</b></dt><dd><a class="el" href="degeneracy_8c.html" title="Execute the algorithm in degeneracy_algorithm.c and print the number of cliques found and wall clock ...">degeneracy.c</a> <a class="el" href="degeneracy__algorithm_8c.html" title="This file contains the algorithm for listing all cliques according to the algorithm of Eppstein et al...">degeneracy_algorithm.c</a> <br/>
<br/>
</dd></dl>
</li>
</ol>
<h2><a class="anchor" id="install_sec"></a>
Compilation and Execution</h2>
<p>Under Linux systems, or *nix, executing "make" or "make all" from the top-level directory should compile all the source files in the <em>src</em> directory, place all object files in the <em>obj</em> directory, and place all executables in the <em>bin</em> directory. The makefile is not very sophisticated, so you may want to always run "make clean" first. If you have gcc and gnu make, this should just work. This code has not been tested in other environments.</p>
<p>Executing the bash shell script "test.sh" in the top-level directory will execute every executable on the data sets in <em>data</em> and print statistics about the data sets.</p>
<h3><a class="anchor" id="Defines"></a>
Defines</h3>
<p>You can modify the defines in the Makefile to alter the behavior of the executables.</p>
<ul>
<li><b>DEBUG</b> - print verbose debug information; may be annoying</li>
<li><b>MEMORY_DEBUG</b> - check for malloc or calloc returning NULL; if so, exit gracefully (causes slightly slower code)</li>
<li><b>RETURN_CLIQUES_ONE_BY_ONE</b> - add cliques to a linked list that is returned by the clique listing algorithms</li>
<li><b>PRINT_CLIQUES_ONE_BY_ONE</b> - print cliques to standard output one per line<ul>
<li>(don't use with define PRINT_CLIQUES_TOMITA_STYLE)</li>
</ul>
</li>
<li><b>PRINT_CLIQUES_TOMITA_STYLE</b> - print cliques as described by Tomita et al. (2006)<ul>
<li>prints to standard output: print the vertex when it is added to the partial clique, print "b" when a vertex is removed, and print "c" when a maximal clique is found. (don't use with define PRINT_CLIQUES_ONE_BY_ONE)</li>
</ul>
</li>
<li><b>ALLOW_ALLOC_ZERO_BYTES</b> - some systems behave strangely when you allocate 0 bytes with either malloc or calloc, if this is not defined, then we always allocated at least one byte.</li>
</ul>
<p>The Defines used to generate the results of Eppstein and Strash (2011) are -DALLOW_ALLOC_ZERO_BYTES and -DPRINT_CLIQUES_TOMITA_STYLE with redirecting the standard output to /dev/null.</p>
<h3><a class="anchor" id="Executables"></a>
Executables</h3>
<p>Each executable reads in the input graph from standard input, and writes the main product to standard output, any statistical information or by-products are printed to standard error.</p>
<ul>
<li>Statistics:<ul>
<li><em>bin/printnm</em> - print the number of vertices and edges in the data set</li>
<li><em>bin/compdegen</em> - compute and print the degeneracy of the data set</li>
</ul>
</li>
</ul>
<ul>
<li>Maximal clique listing: (print number of maximal cliques, and algorithm running time)<ul>
<li><em>bin/tomita</em> - execute algorithm <b>tomita</b> on the data set</li>
<li><em>bin/adjlist</em> - execute algorithm <b>tomita-adjacency-list</b> on the data set</li>
<li><em>bin/hybrid</em> - execute algorithm <b>hybrid</b> on the data set</li>
<li><em>bin/degeneracy</em> - execute algorithm <b>degeneracy</b> on the data set</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="data_sets"></a>
Data Sets</h2>
<p>Several data sets are in the directory <em>data</em>, in a subdirectory named according to their origin.</p>
<h3><a class="anchor" id="Sources"></a>
Sources</h3>
<p>I have included several data sets from BioGRID version 3.0.65 (<a href="http://thebiogrid.org/">http://thebiogrid.org/</a>) in subdirectory <em>biogrid</em>.</p>
<p>See Eppstein and Strash (2011) for more sources</p>
<h3><a class="anchor" id="Format"></a>
Format</h3>
<p>Each file contains the following:</p>
<ol type="1">
<li>The number of vertices in the graph</li>
<li>Twice the number of edges in the graph.</li>
<li>a list of edges in x,y format, where 0&lt;=x,y&lt;number of vertices.<ul>
<li>the graph is symmetric, so x,y and y,x are in the list.</li>
</ul>
</li>
</ol>
<h2><a class="anchor" id="recommended_reading"></a>
Recommended Reading</h2>
<ul>
<li>"The Worst-Case Time Complexity for Generating All Maximal Cliques" by Esuji Tomita, Akira Tanaka, and Haruhisha Takahashi, <em>Theoretical Computer Science</em>, 363(1), 2006. (<a href="http://dx.doi.org/10.1016/j.tcs.2006.06.015">http://dx.doi.org/10.1016/j.tcs.2006.06.015</a>)</li>
</ul>
<ul>
<li>"Listing All Maximal Cliques in Near-Optimal Time" by David Eppstein, Maarten Löffler, and Darren Strash, <em>ISAAC 2010</em>, LNCS volume 6506, pp. 403-416, 2010. (<a href="http://dx.doi.org/10.1007/978-3-642-17517-6_36">http://dx.doi.org/10.1007/978-3-642-17517-6_36</a> or <a href="http://arxiv.org/abs/1006.5440">http://arxiv.org/abs/1006.5440</a>)</li>
</ul>
<ul>
<li>"Listing All Maximal Cliques in Large Sparse Real-World Graphs" by David Eppstein and Darren Strash, <em>SEA 2011</em>, LNCS volume 6630, pp. 364-375, 2011. (<a href="http://dx.doi.org/10.1007/978-3-642-20662-7_31">http://dx.doi.org/10.1007/978-3-642-20662-7_31</a> or <a href="http://arxiv.org/abs/1103.0318">http://arxiv.org/abs/1103.0318</a>) </li>
</ul>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Mon Oct 10 2011 18:59:03 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
