<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<title>src/hybrid_algorithm.c File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javaScript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css"/>
</head>
<body onload='searchBox.OnSelectItem(0);'>
<!-- Generated by Doxygen 1.7.1 -->
<script type="text/javascript"><!--
var searchBox = new SearchBox("searchBox", "search",false,'Search');
--></script>
<div class="navigation" id="top">
  <div class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&nbsp;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&nbsp;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li id="searchli">
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&nbsp;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<h1>src/hybrid_algorithm.c File Reference</h1>  </div>
</div>
<div class="contents">

<p>This file contains an algorithm for listing all cliques according to the "hybrid" algorithm of Eppstein and Strash (SEA 2011).  
<a href="#_details">More...</a></p>
<code>#include &lt;limits.h&gt;</code><br/>
<code>#include &lt;assert.h&gt;</code><br/>
<code>#include &lt;stdio.h&gt;</code><br/>
<code>#include &lt;stdlib.h&gt;</code><br/>
<code>#include &quot;<a class="el" href="misc_8h_source.html">misc.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="_linked_list_8h_source.html">LinkedList.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="_memory_manager_8h_source.html">MemoryManager.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="degeneracy__helper_8h_source.html">degeneracy_helper.h</a>&quot;</code><br/>
<code>#include &quot;<a class="el" href="hybrid__algorithm_8h_source.html">hybrid_algorithm.h</a>&quot;</code><br/>
<table class="memberdecls">
<tr><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">int&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hybrid__algorithm_8c.html#a9777e0a579686461ea92f53eeb7382a4">findBestPivotNonNeighborsHybrid</a> (int **pivotNonNeighbors, int *numNonNeighbors, int *vertexSets, int *vertexLookup, int beginX, int beginP, int beginR, <a class="el" href="struct_neighbor_list_array.html">NeighborListArray</a> **orderingArray, int *scratch)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Computes the vertex v in P union X that has the most neighbors in P, and places P \ {neighborhood of v} in an array. These are the vertices to consider adding to the partial clique during the current recursive call of the algorithm.  <a href="#a9777e0a579686461ea92f53eeb7382a4"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hybrid__algorithm_8c.html#ab80f770254bbf2252a5b8ff0f58d2a86">fillInPandXForRecursiveCallHybrid</a> (int vertex, int orderNumber, int *vertexSets, int *vertexLookup, <a class="el" href="struct_neighbor_list_array.html">NeighborListArray</a> **orderingArray, int *pBeginX, int *pBeginP, int *pBeginR, int *pNewBeginX, int *pNewBeginP, int *pNewBeginR)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move vertex to R, set P to vertex's later neighbors and set X to vertex's earlier neighbors.  <a href="#ab80f770254bbf2252a5b8ff0f58d2a86"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">long&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hybrid__algorithm_8c.html#a52c693221fbcdf8e9ad1c48ff966a3a1">listAllMaximalCliquesHybrid</a> (<a class="el" href="struct_linked_list.html">LinkedList</a> **adjList, int **adjacencyList, <a class="el" href="struct_linked_list.html">LinkedList</a> *cliques, int *degree, int size)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">List all maximal cliques in a given graph using the "hybrid" algorithm by Eppstein et al. (SEA 2011).  <a href="#a52c693221fbcdf8e9ad1c48ff966a3a1"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hybrid__algorithm_8c.html#ad8d701af1d66e16881fa91e42410b256">moveToRHybrid</a> (int vertex, int *vertexSets, int *vertexLookup, <a class="el" href="struct_neighbor_list_array.html">NeighborListArray</a> **orderingArray, int *pBeginX, int *pBeginP, int *pBeginR, int *pNewBeginX, int *pNewBeginP, int *pNewBeginR)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move a vertex to the set R, and update the sets P and X.  <a href="#ad8d701af1d66e16881fa91e42410b256"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hybrid__algorithm_8c.html#a29a98a0782c0bf3d0046dfdab16470b9">moveFromRToXHybrid</a> (int vertex, int *vertexSets, int *vertexLookup, int *pBeginX, int *pBeginP, int *pBeginR)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Move a vertex from the set R to the set X, and update all necessary pointers and arrays of neighbors in P.  <a href="#a29a98a0782c0bf3d0046dfdab16470b9"></a><br/></td></tr>
<tr><td class="memItemLeft" align="right" valign="top">void&nbsp;</td><td class="memItemRight" valign="bottom"><a class="el" href="hybrid__algorithm_8c.html#a617374262b7f87f95b78b32b3eef59e9">listAllMaximalCliquesHybridRecursive</a> (long *cliqueCount, <a class="el" href="struct_linked_list.html">LinkedList</a> *cliques, <a class="el" href="struct_linked_list.html">LinkedList</a> *partialClique, <a class="el" href="struct_neighbor_list_array.html">NeighborListArray</a> **orderingArray, int *vertexSets, int *vertexLookup, int beginX, int beginP, int beginR, int *scratch)</td></tr>
<tr><td class="mdescLeft">&nbsp;</td><td class="mdescRight">Recursively list all maximal cliques containing all of all vertices in R, some vertices in P and no vertices in X.  <a href="#a617374262b7f87f95b78b32b3eef59e9"></a><br/></td></tr>
</table>
<hr/><a name="_details"></a><h2>Detailed Description</h2>
<p>This file contains an algorithm for listing all cliques according to the "hybrid" algorithm of Eppstein and Strash (SEA 2011). </p>
<dl class="author"><dt><b>Author:</b></dt><dd>Darren Strash (first name DOT last name AT gmail DOT com)</dd></dl>
<p>Copyright (c) 2011 Darren Strash. This code is released under the GNU Public License (GPL) 3.0.</p>
<div align="center">
<img src="gplv3-127x51.png" alt="gplv3-127x51.png"/>
</div>
 
    <center>
    <a href="gpl-3.0-standalone.html">See GPL 3.0 here</a>
    </center>
    <p>See the algorithm's description in <a href="http://dx.doi.org/10.1007/978-3-642-17517-6_36">http://dx.doi.org/10.1007/978-3-642-17517-6_36</a></p>
<p>This algorithm first orders the vertices in a degeneracy order (vertices are removed from the graph in order by degree in the remaining subgraph and placed in this order in the ordering).</p>
<p>We then recursively call a modified version of the algorithm of Tomita et al. (2006) <a href="http://dx.doi.org/10.1016/j.tcs.2006.06.015,">http://dx.doi.org/10.1016/j.tcs.2006.06.015,</a> for each vertex v in the ordering, where R = {v}, P = v's neighbors that are after v in the degneracy order, and X = v's neighbors that are before v in the degeneracy order.</p>
<p>This is a recursive backtracking algorithm that maintains three sets of vertices, R, a partial clique, P, the common neighbors of vertices in R that are candidates to add to the partial clique, and X, the set of common neighbors of R that have been listed in a maximal clique with R already.</p>
<p>The algorithm recursively adds vertices to R from P, then updates the sets P and X to be the new common neighbors of R and recurses. When P and X are empty, R is a maximal clique, and is reported.</p>
<p>Updating the sets P and X is done by iterating over the later neighbors of vertices in P and X to see if they contain the vertex v added to R as a neighbor, and then testing if v's later neighbors are in P or X. Neighbors of v remain in their respective sets. For sparse graphs (graphs with low degeneracy) the number of neighbors of any vertex that come later in the degeneracy order is expected to be small. Then testing for neighbors in this way should be fast.</p>
<p>Besides the ordering, this algorithm includes more efficient pivot computation for sparse graphs. To find a "good" pivot, we must find the vertex in P union X that has the most neighbors in P. We accompish this step iterating through each vertex in X and P, and marking each vertex with the number of later neighbors that are in P. (if the vertex is in P, we add one to the count for the vertex itself as well) and then we iterate over the vertices has the highest count. </p>
<hr/><h2>Function Documentation</h2>
<a class="anchor" id="ab80f770254bbf2252a5b8ff0f58d2a86"></a><!-- doxytag: member="hybrid_algorithm.c::fillInPandXForRecursiveCallHybrid" ref="ab80f770254bbf2252a5b8ff0f58d2a86" args="(int vertex, int orderNumber, int *vertexSets, int *vertexLookup, NeighborListArray **orderingArray, int *pBeginX, int *pBeginP, int *pBeginR, int *pNewBeginX, int *pNewBeginP, int *pNewBeginR)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fillInPandXForRecursiveCallHybrid </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>orderNumber</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>vertexSets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>vertexLookup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_neighbor_list_array.html">NeighborListArray</a> **&nbsp;</td>
          <td class="paramname"> <em>orderingArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pBeginX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pBeginP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pBeginR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pNewBeginX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pNewBeginP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pNewBeginR</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Move vertex to R, set P to vertex's later neighbors and set X to vertex's earlier neighbors. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vertex</em>&nbsp;</td><td>The vertex to move to R.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>orderNumber</em>&nbsp;</td><td>The position of vertex in the ordering.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertexSets</em>&nbsp;</td><td>An array containing sets of vertices divided into sets X, P, and other.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertexLookup</em>&nbsp;</td><td>A lookup table indexed by vertex number, storing the index of that vertex in vertexSets.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>orderingArray</em>&nbsp;</td><td>A degeneracy order of the input graph.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pBeginX</em>&nbsp;</td><td>The index where set X begins in vertexSets.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pBeginP</em>&nbsp;</td><td>The index where set P begins in vertexSets.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pBeginR</em>&nbsp;</td><td>The index where set R begins in vertexSets.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pNewBeginX</em>&nbsp;</td><td>After function, contains the new index where set X begins in vertexSets after adding vertex to R.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pNewBeginP</em>&nbsp;</td><td>After function, contains the new index where set P begins in vertexSets after adding vertex to P.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pNewBeginR</em>&nbsp;</td><td>After function, contains the new index where set R begins in vertexSets after adding vertex to R. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a9777e0a579686461ea92f53eeb7382a4"></a><!-- doxytag: member="hybrid_algorithm.c::findBestPivotNonNeighborsHybrid" ref="a9777e0a579686461ea92f53eeb7382a4" args="(int **pivotNonNeighbors, int *numNonNeighbors, int *vertexSets, int *vertexLookup, int beginX, int beginP, int beginR, NeighborListArray **orderingArray, int *scratch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int findBestPivotNonNeighborsHybrid </td>
          <td>(</td>
          <td class="paramtype">int **&nbsp;</td>
          <td class="paramname"> <em>pivotNonNeighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>numNonNeighbors</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>vertexSets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>vertexLookup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>beginX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>beginP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>beginR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_neighbor_list_array.html">NeighborListArray</a> **&nbsp;</td>
          <td class="paramname"> <em>orderingArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>scratch</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Computes the vertex v in P union X that has the most neighbors in P, and places P \ {neighborhood of v} in an array. These are the vertices to consider adding to the partial clique during the current recursive call of the algorithm. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>pivotNonNeighbors</em>&nbsp;</td><td>An intially unallocated pointer, which will contain the set P \ {neighborhood of v} when this function completes.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>numNonNeighbors</em>&nbsp;</td><td>A pointer to a single integer, which has been preallocated, which will contain the number of elements in pivotNonNeighbors.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertexSets</em>&nbsp;</td><td>An array containing sets of vertices divided into sets X, P, R, and other.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertexLookup</em>&nbsp;</td><td>A lookup table indexed by vertex number, storing the index of that vertex in vertexSets.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>beginX</em>&nbsp;</td><td>The index where set X begins in vertexSets.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>beginP</em>&nbsp;</td><td>The index where set P begins in vertexSets.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>beginR</em>&nbsp;</td><td>The index where set R begins in vertexSets.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>orderingArray</em>&nbsp;</td><td>A array storing the degeneracy order, with each vertex containing arrays of its later and earlier neighbrs in the order.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scratch</em>&nbsp;</td><td>An array that we use for scratch space to avoid allocating and deallocating memory often. We use this space to count how many neighbors each vertex has in P.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the pivot that is chosen from P union X </dd></dl>

</div>
</div>
<a class="anchor" id="a52c693221fbcdf8e9ad1c48ff966a3a1"></a><!-- doxytag: member="hybrid_algorithm.c::listAllMaximalCliquesHybrid" ref="a52c693221fbcdf8e9ad1c48ff966a3a1" args="(LinkedList **adjList, int **adjacencyList, LinkedList *cliques, int *degree, int size)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">long listAllMaximalCliquesHybrid </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="struct_linked_list.html">LinkedList</a> **&nbsp;</td>
          <td class="paramname"> <em>adjList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int **&nbsp;</td>
          <td class="paramname"> <em>adjacencyList</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_linked_list.html">LinkedList</a> *&nbsp;</td>
          <td class="paramname"> <em>cliques</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>degree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>size</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>List all maximal cliques in a given graph using the "hybrid" algorithm by Eppstein et al. (SEA 2011). </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>adjList</em>&nbsp;</td><td>An array of linked lists, representing the input graph in the "typical" adjacency list format.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>adjacencyList</em>&nbsp;</td><td>an array of arrays, representing the input graph in a more compact and cache-friendly adjacency list format. (not currently used)</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cliques</em>&nbsp;</td><td>A linked list of cliques to return. <b>(only available when compiled with RETURN_CLIQUES_ONE_BY_ONE defined)</b></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>degree</em>&nbsp;</td><td>An array, indexed by vertex, containing the degree of that vertex. (not currently used)</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>size</em>&nbsp;</td><td>The number of vertices in the graph.</td></tr>
  </table>
  </dd>
</dl>
<dl class="return"><dt><b>Returns:</b></dt><dd>the number of maximal cliques of the input graph. </dd></dl>

</div>
</div>
<a class="anchor" id="a617374262b7f87f95b78b32b3eef59e9"></a><!-- doxytag: member="hybrid_algorithm.c::listAllMaximalCliquesHybridRecursive" ref="a617374262b7f87f95b78b32b3eef59e9" args="(long *cliqueCount, LinkedList *cliques, LinkedList *partialClique, NeighborListArray **orderingArray, int *vertexSets, int *vertexLookup, int beginX, int beginP, int beginR, int *scratch)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void listAllMaximalCliquesHybridRecursive </td>
          <td>(</td>
          <td class="paramtype">long *&nbsp;</td>
          <td class="paramname"> <em>cliqueCount</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_linked_list.html">LinkedList</a> *&nbsp;</td>
          <td class="paramname"> <em>cliques</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_linked_list.html">LinkedList</a> *&nbsp;</td>
          <td class="paramname"> <em>partialClique</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_neighbor_list_array.html">NeighborListArray</a> **&nbsp;</td>
          <td class="paramname"> <em>orderingArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>vertexSets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>vertexLookup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>beginX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>beginP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>beginR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>scratch</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Recursively list all maximal cliques containing all of all vertices in R, some vertices in P and no vertices in X. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>cliqueCount</em>&nbsp;</td><td>A pointer to the number of maximal cliques computed thus far.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>cliques</em>&nbsp;</td><td>A linked list of cliques to return. <b>(only available when compiled with RETURN_CLIQUES_ONE_BY_ONE defined)</b></td></tr>
    <tr><td valign="top"></td><td valign="top"><em>partialClique</em>&nbsp;</td><td>A linked list storing R, the partial clique for this recursive call.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>orderingArray</em>&nbsp;</td><td>A array storing the degeneracy order, with each vertex containing arrays of its later and earlier neighbrs in the order.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertexSets</em>&nbsp;</td><td>An array containing sets of vertices divided into sets X, P, R and other.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertexLookup</em>&nbsp;</td><td>A lookup table indexed by vertex number, storing the index of that vertex in vertexSets.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>beginX</em>&nbsp;</td><td>The index where set X begins in vertexSets.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>beginP</em>&nbsp;</td><td>The index where set P begins in vertexSets.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>beginR</em>&nbsp;</td><td>The index where set R begins in vertexSets.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>scratch</em>&nbsp;</td><td>An array that we use for scratch space to avoid allocating and deallocating memory often. We use this space to count how many neighbors each vertex has in P. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="a29a98a0782c0bf3d0046dfdab16470b9"></a><!-- doxytag: member="hybrid_algorithm.c::moveFromRToXHybrid" ref="a29a98a0782c0bf3d0046dfdab16470b9" args="(int vertex, int *vertexSets, int *vertexLookup, int *pBeginX, int *pBeginP, int *pBeginR)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void moveFromRToXHybrid </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>vertexSets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>vertexLookup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pBeginX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pBeginP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pBeginR</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Move a vertex from the set R to the set X, and update all necessary pointers and arrays of neighbors in P. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vertex</em>&nbsp;</td><td>The vertex to move from R to X.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertexSets</em>&nbsp;</td><td>An array containing sets of vertices divided into sets X, P, R, and other.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertexLookup</em>&nbsp;</td><td>A lookup table indexed by vertex number, storing the index of that vertex in vertexSets.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pBeginX</em>&nbsp;</td><td>The index where set X begins in vertexSets.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pBeginP</em>&nbsp;</td><td>The index where set P begins in vertexSets.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pBeginR</em>&nbsp;</td><td>The index where set R begins in vertexSets. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a class="anchor" id="ad8d701af1d66e16881fa91e42410b256"></a><!-- doxytag: member="hybrid_algorithm.c::moveToRHybrid" ref="ad8d701af1d66e16881fa91e42410b256" args="(int vertex, int *vertexSets, int *vertexLookup, NeighborListArray **orderingArray, int *pBeginX, int *pBeginP, int *pBeginR, int *pNewBeginX, int *pNewBeginP, int *pNewBeginR)" -->
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void moveToRHybrid </td>
          <td>(</td>
          <td class="paramtype">int&nbsp;</td>
          <td class="paramname"> <em>vertex</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>vertexSets</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>vertexLookup</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="struct_neighbor_list_array.html">NeighborListArray</a> **&nbsp;</td>
          <td class="paramname"> <em>orderingArray</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pBeginX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pBeginP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pBeginR</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pNewBeginX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pNewBeginP</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&nbsp;</td>
          <td class="paramname"> <em>pNewBeginR</em></td><td>&nbsp;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td><td><code> [inline]</code></td>
        </tr>
      </table>
</div>
<div class="memdoc">

<p>Move a vertex to the set R, and update the sets P and X. </p>
<dl><dt><b>Parameters:</b></dt><dd>
  <table border="0" cellspacing="2" cellpadding="0">
    <tr><td valign="top"></td><td valign="top"><em>vertex</em>&nbsp;</td><td>The vertex to move to R.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertexSets</em>&nbsp;</td><td>An array containing sets of vertices divided into sets X, P, R, and other.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>vertexLookup</em>&nbsp;</td><td>A lookup table indexed by vertex number, storing the index of that vertex in vertexSets.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>orderingArray</em>&nbsp;</td><td>A degeneracy order of the input graph.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pBeginX</em>&nbsp;</td><td>The index where set X begins in vertexSets.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pBeginP</em>&nbsp;</td><td>The index where set P begins in vertexSets.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pBeginR</em>&nbsp;</td><td>The index where set R begins in vertexSets.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pNewBeginX</em>&nbsp;</td><td>After function, contains the new index where set X begins in vertexSets after adding vertex to R.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pNewBeginP</em>&nbsp;</td><td>After function, contains the new index where set P begins in vertexSets after adding vertex to P.</td></tr>
    <tr><td valign="top"></td><td valign="top"><em>pNewBeginR</em>&nbsp;</td><td>After function, contains the new index where set R begins in vertexSets after adding vertex to R. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
</div>
<!--- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&nbsp;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&nbsp;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&nbsp;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&nbsp;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&nbsp;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&nbsp;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&nbsp;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<hr class="footer"/><address class="footer"><small>Generated on Mon Oct 10 2011 18:59:03 by&nbsp;
<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.1 </small></address>
</body>
</html>
