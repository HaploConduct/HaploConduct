SAVAGE is a computational tool for reconstructing individual 
haplotypes of intra-host virus strains (a viral quasispecies) without 
the need for a high quality reference genome. SAVAGE makes use of 
either FM-index based data structures or ad-hoc consensus reference 
sequence for constructing overlap graphs from patient sample data. 
In this overlap graph, nodes represent reads and/or contigs, while 
edges reflect that two reads/contigs, based on sound statistical 
considerations, represent identical haplotypic sequence.  
Following an iterative scheme, a new overlap assembly algorithm that 
is based on the enumeration of statistically well-calibrated groups 
of reads/contigs then efficiently reconstructs the individual 
haplotypes from this overlap graph.
  
******************************
REQUIREMENTS and INSTALLATION:
******************************

The SAVAGE program is a combination of C++ code (which has to be 
compiled) and Python scripts (version 2.6 or later, but not Python 
3.x). The C++ part requires several boost libraries (boost::timer, 
boost::system, and boost::program_options) and it needs OpenMP.

For maximal clique enumeration, SAVAGE depends on the quick-cliques 
package (https://github.com/darrenstrash/quick-cliques) which is 
included. 

Stages b and c of the algorithm also require BLAST from the ncbi C++ 
Toolkit.

Complete installation instructions can be found in the INSTALL file.

*******
MANUAL:
*******

Currently, SAVAGE is designed for Illumina MiSeq sequencing reads 
that have been pre-processed by PEAR (for merging self-overlapping 
pairs). Thus, the input consists of both single-end and paired-end 
reads.

SAVAGE offers two modes:

A. SAVAGE-ref

This mode constructs the overlap graph of the reads 
using the pairwise overlaps induced from a read-to-reference 
alignment. Hence, it takes as input a reference genome and alignment
files in SAM format (https://samtools.github.io/hts-specs/SAMv1.pdf). 

SAVAGE has proven to work not only on high-quality, well-curated 
reference genomes, but also on ad-hoc consensus genomes constructed 
from the read set itself using a de novo assembler (such as VICUNA).
Therefore, even in ref-mode, SAVAGE can be used to compute very 
accurate de novo viral quasispecies assemblies.

To run SAVAGE-ref, complete the following steps:

1) Download or assemble a reference genome <reference.fasta>
2) Create a directory <my_directory> where you want to store the 
   results, and add a folder 
                pear_reads/
   containing               singles.fastq
                            paired1.fastq 
                            paired2.fastq
   Make sure that the read identifiers are numerical, with IDs 
   0 to num_singles-1 for the single-end reads and IDs num_singles 
   to num_singles+num_pairs-1 for the paired-end reads.
3) Align the single- and paired-end reads seperately to this 
   reference, obtaining 
                singles.sam
                paired.sam
4) Now you're ready to run SAVAGE: enter <my_directory> and run

       python savage.py --ref <reference.fasta> 
                        --singles <singles.sam>
                        --paired <paired.sam>

B. SAVAGE-de-novo

This mode does not rely on any reference sequence; instead, it 
computes all approximate suffix-prefix overlaps among the reads 
using the included package SFO from Valimaki et al.
(https://www.cs.helsinki.fi/group/suds/sfo/). 

SAVAGE-de-novo is very easy to run, since it doesn't use any prior
information:

1) Create a directory <my_directory> where you want to store the 
   results, and add a folder 
                pear_reads/
   containing               singles.fastq
                            paired1.fastq 
                            paired2.fastq
   Make sure that the read identifiers are numerical, with IDs 
   0 to num_singles-1 for the single-end reads and IDs num_singles 
   to num_singles+num_pairs-1 for the paired-end reads.
2) Now you're ready to run SAVAGE: enter <my_directory> and run

       python savage.py


*********************
FREQUENCY ESTIMATION:
*********************


********
Example:
********

The directory example/ contains a small working example, with both 
single- and paired-end reads contained in pear_reads/ and alignments
singles.sam, paired.sam to an HIV-1 HXB2 reference strain 
(hiv-ref.fasta). 

To run the example, cd into example/ and
                        
A) for SAVAGE-ref execute:

                        python savage.py --ref <reference.fasta> 
                                         --singles <singles.sam>
                                         --paired <paired.sam>
B) for SAVAGE-de-novo execute:

                        python savage.py
                                         
Then apply the frequency estimation procedure on Stage b contigs:

    python ../freq_est.py --fas stage_b/singles.fastq 
                          --subreads stage_b/subreads.txt 
                          --min_len 0
    
The desired output of this final procedure is given in 
A) frequencies.ref.txt
B) frequencies.denovo.txt


****************
General remarks:
****************

SAVAGE expects as input single- and/or paired-end reads. For the 
paired-end reads, it assumes they are stored both on the same strand 
(hence resulting in F-F alignments) as output by PEAR (Paired-End 
reAd mergeR: http://sco.h-its.org/exelixis/web/software/pear/).

The algorithm proceeds in three stages: 
* Stage a has the original reads as input and contigs
* Stage b has these contigs as input and maximally extended contigs 
  as output
* Stage c (OPTIONAL) merges maximized contigs into master strain 
  sequences.
By default, SAVAGE runs all three stages, but the output of Stage b 
(contigs_stage_b.fasta) is considered as the viral quasispecies 
assembly. 

SAVAGE performs error correction on the reads in the first iteration 
of Stage a, which has been optimized for a coverage of 500x-1000x. 
In case of (ultra-)deep sequencing data, exceeding a coverage of 
1000x, it is currently required to split the data into patches of 
500x. Then, on each of these subsets, run only SAVAGE Stage a:

       python savage.py --ref <reference.fasta> 
                        --singles <singles.sam>
                        --paired <paired.sam>
                        --no_stage_b
                        --no_stage_c
                        
Then concatenate the resulting contig files (stage_a/singles.fastq) 
into a file <combined_contigs.fastq>. Now enter <my_directory> and 
run SAVAGE Stages b and c:

       python savage.py --no_stage_a 
                        --contigs <combined_contigs.fastq>


********
CONTACT:
********    

In case of any questions or issues, please contact Jasmijn Baaijens: 
<lastname> AT cwi DOT nl
